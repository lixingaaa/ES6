<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    /**
     * 含义
     * ES2017 标准引入了 async 函数，使得异步操作变得更加方便,它就是 Generator 函数的语法糖。
     **/
    {
      // Generator 函数，依次读取两个文件
      // const fs = require('fs');

      // const readFile = function (fileName) {
      //   return new Promise(function (resolve, reject) {
      //     fs.readFile(fileName, function (error, data) {
      //       if (error) return reject(error);
      //       resolve(data);
      //     });
      //   });
      // };

      // const gen = function* () {
      //   const f1 = yield readFile('/etc/fstab');
      //   const f2 = yield readFile('/etc/shells');
      //   console.log(f1.toString());
      //   console.log(f2.toString());
      // };

      // 上面代码的函数gen可以写成async函数
      // async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。
      // const asyncReadFile = async function () {
      //   const f1 = await readFile('/etc/fstab');
      //   const f2 = await readFile('/etc/shells');
      //   console.log(f1.toString());
      //   console.log(f2.toString());
      // };
    }

    {
      // async函数对 Generator 函数的改进，体现在以下四点。
      // (1) 内置执行器, Generator 函数的执行必须靠执行器， 所以才有了co模块， 而async函数自带执行器。 也就是说， async函数的执行， 与普通函数一模一样， 只要一行。
      asyncReadFile();
      // (2) 更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。
      // (3) 更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。
      // (4) 返回值是Promise,async函数的返回值是 Promise 对象，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。
    }
  </script>
</body>

</html>