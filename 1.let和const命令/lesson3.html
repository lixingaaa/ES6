<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    /**
     * const常量
     * const声明一个只读的常量。一旦声明，常量的值就不能改变。
     * const一旦声明变量，就必须立即初始化，不能留到以后赋值。
     * const的作用域与let命令相同：只在声明所在的块级作用域内有效。
     * const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
     * const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
     * 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
     * 对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），
     **/
    const PI = 3.1415;
    // PI = 3;  // 报错, 一旦声明不能改变

    // const foo; // 报错，声明后必须立即初始化

    if (true) {
      const MAX = 5;
    }
    // MAX; // MAX is not defined, 只在声明所在的块级作用域内有效

    if (true) {
      // console.log(MAX) // 报错，声明之前就调用
      const MAX = 5
    }

    const foo = {}
    // 为foo添加属性，可以成功
    foo.prop = 123
    foo.prop; // 123
    // 将foo指向另外一个对象，报错
    // foo = {}

    // 对象冻结
    const foo_freeze = Object.freeze({});
    // 添加属性不起作用 
    foo_freeze.prop = 123

    // 冻结对象属性，将对象彻底冻结
    var constantize = (obj) => {
      Object.freeze(obj);
      Object.keys(obj).forEach((key, i) => {
        if (typeof obj[key] === 'object') {
          constantize(obj[key])
        }
      })
    }
  </script>
</body>

</html>